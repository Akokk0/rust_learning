# 泛型，Trait，生命周期
## 提取函数消除重复
### 重复代码
- 重复代码的危害：
  - 容易出错
  - 需求变更时需要在多处进行修改
- 消除重复：提取函数

### 消除重复的步骤
- 识别重复代码
- 提取重复代码到函数体中，并在函数签名中指定函数的输入和返回值
- 将重复的代码使用函数调用进行代替

## 泛型
### 泛型
- 提高代码复用能力
  - 处理重复代码的问题
- 泛型是具体类型或其它属性的抽象代替：
  - 你编写的代码不是最终的代码，而是一种模版，里面有一些"占位符"
  - 编译器在编译时将"占位符"替换为具体的类型
- 例如：fn largest<T>(list: &[T]) -> T {...}
- 类型参数：
  - 很短，通常一个字母
  - CamelCase(驼峰命名)
  - T: type的缩写

### 函数定义中的泛型
- 泛型函数：
  - 参数类型
  - 返回类型

### Struct定义中的泛型
- 可以使用多个泛型的类型参数
  - 太多类型参数：你的代码需要重组为多个更小的单元

### Enum定义中的泛型
- 可以让枚举的变体持有泛型数据类型
  - 例如Option<T>, Result<T, E>

### 方法定义中的泛型
- 为struct或enum实现方法的时候，可在定义中使用泛型
- 注意：
  - 把T放在impl关键字后，表示在类型T上实现方法
    - 例如：impl<T> Point<T>
  - 只针对具体类型实现方法(其余类型没实现方法)：
    - 例如impl Point<f32>
- struct里的泛型类型参数可以和方法的泛型类型参数不同

### 泛型代码的性能
- 使用泛型的代码和使用具体类型的代码运行速度是一样的
- 单态化(monomorphization):
  - 在编译时将泛型替换为具体类型的过程

## Trait
### Trait
- Trait告诉Rust编译器：
  - 某种类型具有哪些并且可以与其他类型共享的功能
- Trait：抽象的定义共享行为
- Trait bounds(约束)：泛型类型参数指定为实现了特定行为的类型
- Trait与其他语言的接口(interface)类似，但有些区别

### 定义一个Trait
- Trait的定义：把方法签名放在一起，来定义实现某种目的所必须的一组行为
  - 关键字：trait
  - 只有方法签名，没有具体实现
  - trait可以有多个方法：每个方法签名占一行，以;结尾
  - 实现该trait的类型必须提供具体的方法实现

### 在类型上实现trait
- 与为类型实现方法类似
- 不同之处：
  - impl Xxxx for Tweet {...}
  - 在impl的块里，需要对Trait里的方法签名进行具体的实现

### 实现trait的约束
- 可以在某个类型上实现某个trait的前提条件是：
  - 这个类型或这个trait是在本地crate里定义的
- 无法为外部类型来实现外部的trait:
  - 这个限制是程序属性的一部分(也就是一致性)
  - 更具体地说是孤儿规则：之所以这样命名是因为父类型不存在
  - 此规则确保其他人的代码不能破坏您的代码，反之亦然
  - 如果没有这个规则，两个crate可以为同一类型实现同一个trait，Rust就不知道应该使用哪个实现了

### 默认实现
- 默认实现的方法可以调用trait中其它的方法，即使这些方法没有默认实现
- 注意：无法从方法的重写实现里面调用默认的实现

### Trait作为参数
- impl Trait 语法：适用于简单情况
- Trait bound语法：可用于复杂情况
  - impl Trait语法是Trait bound的语法糖
- 使用+指定多个Trait bound
- Trait bound使用where子句
  - 在方法签名后指定where子句

### 实现Trait作为返回类型
- impl Trait语法
- 注意：impl Trait只能返回确定的同一种类型，返回可能不同类型的代码会报错

### 使用Trait Bound的例子
- 使用Trait Bound修复largest函数

### 使用Trait Bound有条件的实现方法
- 在使用泛型类型参数的impl块上使用Trait bound，我们可以有条件的为实现了特定Trait的类型来实现方法
- 也可以为实现了其它Trait的任意类型有条件的实现某个Trait
- 为满足Trait Bound的所有类型上实现Trait叫做覆盖实现(blanket implementations)

## 生命周期
### 生命周期
- Rust 中的每一个引用都有其 生命周期（lifetime）
- 也就是引用保持有效的作用域
- 大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样
- 类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的

### 生命周期 - 避免悬垂引用(dangling reference)
- 生命周期的主要目标是避免悬垂引用（dangling references）

### 借用检查器
- Rust 编译器有一个 借用检查器（borrow checker），它比较作用域来确保所有的借用都是有效的

### 函数中的泛型生命周期
