# 泛型，Trait，生命周期
## 提取函数消除重复
### 重复代码
- 重复代码的危害：
  - 容易出错
  - 需求变更时需要在多处进行修改
- 消除重复：提取函数

### 消除重复的步骤
- 识别重复代码
- 提取重复代码到函数体中，并在函数签名中指定函数的输入和返回值
- 将重复的代码使用函数调用进行代替

## 泛型
### 泛型
- 提高代码复用能力
  - 处理重复代码的问题
- 泛型是具体类型或其它属性的抽象代替：
  - 你编写的代码不是最终的代码，而是一种模版，里面有一些"占位符"
  - 编译器在编译时将"占位符"替换为具体的类型
- 例如：fn largest<T>(list: &[T]) -> T {...}
- 类型参数：
  - 很短，通常一个字母
  - CamelCase(驼峰命名)
  - T: type的缩写

### 函数定义中的泛型
- 泛型函数：
  - 参数类型
  - 返回类型

### Struct定义中的泛型
- 可以使用多个泛型的类型参数
  - 太多类型参数：你的代码需要重组为多个更小的单元

### Enum定义中的泛型
- 可以让枚举的变体持有泛型数据类型
  - 例如Option<T>, Result<T, E>

### 方法定义中的泛型
- 为struct或enum实现方法的时候，可在定义中使用泛型
- 注意：
  - 把T放在impl关键字后，表示在类型T上实现方法
    - 例如：impl<T> Point<T>
  - 只针对具体类型实现方法(其余类型没实现方法)：
    - 例如impl Point<f32>
- struct里的泛型类型参数可以和方法的泛型类型参数不同

### 泛型代码的性能
- 使用泛型的代码和使用具体类型的代码运行速度是一样的
- 单态化(monomorphization):
  - 在编译时将泛型替换为具体类型的过程

## Trait
### Trait
- Trait告诉Rust编译器：
  - 某种类型具有哪些并且可以与其他类型共享的功能
- Trait：抽象的定义共享行为
- Trait bounds(约束)：泛型类型参数指定为实现了特定行为的类型
- Trait与其他语言的接口(interface)类似，但有些区别

### 定义一个Trait
- Trait的定义：把方法签名放在一起，来定义实现某种目的所必须的一组行为
  - 关键字：trait
  - 只有方法签名，没有具体实现
  - trait可以有多个方法：每个方法签名占一行，以;结尾
  - 实现该trait的类型必须提供具体的方法实现

### 在类型上实现trait
- 与为类型实现方法类似
- 不同之处：
  - impl Xxxx for Tweet {...}
  - 在impl的块里，需要对Trait里的方法签名进行具体的实现

### 实现trait的约束
- 可以在某个类型上实现某个trait的前提条件是：
  - 这个类型或这个trait是在本地crate里定义的
- 无法为外部类型来实现外部的trait:
  - 这个限制是程序属性的一部分(也就是一致性)
  - 更具体地说是孤儿规则：之所以这样命名是因为父类型不存在
  - 此规则确保其他人的代码不能破坏您的代码，反之亦然
  - 如果没有这个规则，两个crate可以为同一类型实现同一个trait，Rust就不知道应该使用哪个实现了

### 默认实现
- 默认实现的方法可以调用trait中其它的方法，即使这些方法没有默认实现
- 注意：无法从方法的重写实现里面调用默认的实现

### Trait作为参数
- impl Trait 语法：适用于简单情况
- Trait bound语法：可用于复杂情况
  - impl Trait语法是Trait bound的语法糖
- 使用+指定多个Trait bound
- Trait bound使用where子句
  - 在方法签名后指定where子句

### 实现Trait作为返回类型
- impl Trait语法
- 注意：impl Trait只能返回确定的同一种类型，返回可能不同类型的代码会报错

### 使用Trait Bound的例子
- 使用Trait Bound修复largest函数

### 使用Trait Bound有条件的实现方法
- 在使用泛型类型参数的impl块上使用Trait bound，我们可以有条件的为实现了特定Trait的类型来实现方法
- 也可以为实现了其它Trait的任意类型有条件的实现某个Trait
- 为满足Trait Bound的所有类型上实现Trait叫做覆盖实现(blanket implementations)

## 生命周期
### 生命周期
- Rust 中的每一个引用都有其 生命周期（lifetime）
- 也就是引用保持有效的作用域
- 大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样
- 类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的

### 生命周期 - 避免悬垂引用(dangling reference)
- 生命周期的主要目标是避免悬垂引用（dangling references）

### 借用检查器
- Rust 编译器有一个 借用检查器（borrow checker），它比较作用域来确保所有的借用都是有效的

### 函数中的泛型生命周期
- 生命周期注解并不改变任何引用的生命周期的长短
- 相反它们描述了多个引用生命周期相互的关系，而不影响其生命周期
- 与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用

### 生命周期注解有着一个不太常见的语法
- 生命周期参数
  - 名称必须以撇号（'）开头
  - 其名称通常全是小写，类似于泛型其名称非常短
  - 大多数人使用 'a 作为第一个生命周期注解

- 生命周期参数注解
  - 位于引用的 & 之后
  - 并有一个空格来将引用类型与生命周期注解分隔开

### 生命周期标注 - 例子
- &i32  // 一个引用
- &'a i32  // 带有显式生命周期的引用
- &'a mut i32  // 带有显式生命周期的可变引用
- 单个生命周期标注本身没有意义

### 函数签名中的生命周期注解
- 为了在函数签名中使用生命周期注解，需要在函数名和参数列表间的尖括号中声明泛型生命周期（lifetime）参数，就像泛型类型（type）参数一样
- 生命周期'a的实际生命周期是：x和y两个生命周期中较小的那个

### 深入理解生命周期
- 指定生命周期参数的方式依赖于函数所做的事情
- 从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配
- 如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值：
  - 这就是悬垂引用：该值在函数结束时就走出了作用域

### Struct定义中的生命周期标注
- 自持有的类型
- 引用：需要在每个引用上添加生命周期标注

### 生命周期的省略
- 我们知道：
  - 每个引用都有生命周期
  - 需要为使用生命周期的函数或struct指定生命周期参数

### 生命周期省略规则
- 在Rust引用分析中所编入的模式称为生命周期省略规则
  - 这些规则无需开发者遵守
  - 它们是一些特殊情况，由编译器来考虑
  - 如果你的代码符合这些情况，那么就无需显式标注生命周期
- 生命周期省略规则不会提供完整的推断：
  - 如果应用规则后，引用的生命周期仍然模糊不清 -> 编译错误
  - 解决办法：添加生命周期标注，表明引用间的相互关系

### 输入、输出生命周期
- 生命周期在：
  - 函数/方法的参数：输入生命周期
  - 函数/方法的返回值：输出生命周期

### 生命周期省略的三个规则
- 编译器使用3个规则在没有显式标注生命周期的情况下，来确定引用的生命周期
  - 规则1应用于输入生命周期
  - 规则2、3应用于输出生命周期
  - 如果编译器应用完3个规则之后，仍然有无法确定生命周期的引用 -> 报错
  - 这些规则适用于fn定义和impl块
- 规则1：每个引用类型的参数都有自己的生命周期
- 规则2：如果只有1个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数
- 如果有多个输出生命周期参数，但其中一个是&self或&mut self(是方法)，那么self的生命周期会被赋给所有的输出生命周期参数

### 方法定义中的生命周期标注
- 在struct上使用生命周期实现方法，语法和泛型参数的语法一样
- 在哪声明和使用生命周期参数，依赖于：
  - 生命周期参数是否和字段、方法的参数或返回值有关
- struct字段的生命周期名：
  - 在impl后声明
  - 在struct名后使用
  - 这些生命周期是struct类型的一部分
- impl块内的方法签名中：
  - 引用必须绑定于struct字段引用的生命周期，或者引用是独立的也可以
  - 生命周期省略规则经常使得方法中的生命周期标注不是必须的

### 静态生命周期
- 'static 是一个特殊的生命周期：整个程序的持续时间
  - 例如：所有的字符串字面值都拥有'static生命周期
    - let s: &;static str = "I have a static lifetime.";
- 为引用指定'static生命周期前要三思：
  - 是否需要引用在程序整个生命周期内都存活