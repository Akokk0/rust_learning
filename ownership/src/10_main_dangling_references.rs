fn main() {
    // Dangling References 悬空引用
    // 一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用了
    // 在Rust里，编译器可保证引用永远都不是悬空引用：
    //   - 如果你引用了某些数据，编译器讲保证在引用离开作用域之前数据不会离开作用域

    let r = dangle();
}

fn dangle() -> &String { // s在离开作用域就会被销毁，返回该值将变成空指针是不合法的
    let s = String::from("hello");
    &s
}

/* 引用的规则：
    · 在任何给定的时刻，只能满足下列条件之一：
        - 一个可变的引用
        - 任意数量不可变的引用
    · 引用必须一直有效
*/